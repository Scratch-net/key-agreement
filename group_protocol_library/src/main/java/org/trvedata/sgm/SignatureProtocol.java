package org.trvedata.sgm;

import org.apache.commons.lang3.tuple.Pair;
import org.trvedata.sgm.crypto.IdentityKey;
import org.trvedata.sgm.misc.ByteHolder;

/**
 * A {@link SignatureProtocol} is the interface used by {@link ModularDsgm} to handle authentication in the form of
 * signatures.  A SignatureProtocol is intended to be post-compromise secure, updating keys when {@link
 * SignatureProtocol#update} is called.
 * <p>
 * {@link SignatureProtocol} objects should be immutable.  "Mutating" methods must return a new
 * {@link SignatureProtocol} while leaving the original unchanged.
 * <p>
 * This is based on the Ratcheting Digital Signatures scheme definition appearing in Section 5.1 of "Efficient
 * Post-Compromise Security Beyond One Group", Version 2.0, by Cremers, Hale, and Kohbrok, December 2019
 * (https://eprint.iacr.org/2019/477).
 */
public interface SignatureProtocol<S extends SignatureProtocol.State> {

    /**
     * Signs the given message under the current signature scheme.
     *
     * @param state   The state to reference (immutably).
     * @param message The message to be signed.
     * @return The signature for the message (excluding the message itself).
     */
    Signature getSignature(S state, byte[] message);

    /**
     * Verifies that {@code signature} is a valid signature for {@code message} with sender {@code sender}.  If {@code
     * sender} has not been referenced before in {@link SignatureProtocol#processUpdate} or {@link
     * SignatureProtocol#processWelcomeInfo}, then they should be treated as a new group member who has not yet updated.
     * (Typically this means the message will be signed under {@code sender.getPublicKey()}.)  Otherwise, {@code
     * signature} should be verified using the current state corresponding to {@code sender}, according to their past
     * update messages.  In particular, {@code signature} might not be a signature under {@code sender.getPublicKey()}.
     *
     * @param state     The state to reference (immutably).
     * @param isWelcome True if {@code message} is a Welcome Message, i.e., it is being used to add us to the group.
     *                  Either the first message passed to {@code verify} will be a Welcome Message, or {@link
     *                  SignatureProtocol#getWelcomeSignature} will be the first method called; the latter only occurs
     *                  if we create the group.  In any case, no subsequent messages passed to {@code verify} will have
     *                  {@code isWelcome==true}.
     * @param message   The message that was signed.  This excludes {@code signature}.
     * @param sender    The {@link IdentityKey} of the sender.  Note that this is the public key used to identify the
     *                  group member, not necessarily the key used to sign {@code message}.
     * @param signature The signature.
     * @return Whether the signature is valid.
     */
    boolean verify(S state, boolean isWelcome, byte[] message, IdentityKey sender, Signature signature);

    /**
     * Tells the {@code SignatureProtocol} to perform an update on its signing key, in a post-compromise secure
     * fashion.
     * <p>
     *
     * @param state The state to reference (immutably).
     * @return The updated state, and a Signature Update Message to send
     * to other group members to inform them of this update. The update message need not be authenticated, as ModularDgm
     * will authenticate it the usual way using getSignature.  Note that the original (non-updated) state
     * will be used to calculate the signature on the update message, so that other users can authenticate
     * the update before applying it.
     */
    Pair<S, Update> update(S state);

    /**
     * Processes a Signature Update Message generated by another user's {@link SignatureProtocol#update} method, so that
     * we can correctly check signatures under their updated keys.  Updates will be delivered to {@code processUpdate}
     * in causal order, so in particular, each other user's updates will be delivered in the order they were generated.
     * This method is not applied to our own updates.
     *
     * @param state  The state to reference (immutably).
     * @param update The Signature Update Message output by {@code sender}'s {@link SignatureProtocol#update} method.
     * @param sender The {@link IdentityKey} of the sender.  Note that this is the public key used to identify the group
     *               member, not necessarily their current signing key.
     * @return The updated state
     */
    S processUpdate(S state, Update update, IdentityKey sender);

    /**
     * Returns welcome information to be passed to a new group member via their {@link
     * SignatureProtocol#processWelcomeInfo} method, so that they can learn the current state of the group signature
     * scheme.  For example, the welcome info could contain a map from each current or former group member's {@link
     * IdentityKey} to their current public signing key, possibly optimized so that no mapping is included for group
     * members that have never updated their signature key.  It need not contain the complete list of current group
     * member's {@link IdentityKey}'s, since {@link SignatureProtocol#verify} gracefully handles {@code sender}'s it has
     * not seen before by treating them as group members that have not yet updated, and thus the {@link
     * SignatureProtocol} does not need advance notice of these members.
     * <p>
     * This should be called after applying any update resulting from the corresponding add message.
     * <p>
     * This is not called if we create the group, only if we are adding a new user after group creation.
     *
     * @param state The state to reference (immutably).
     * @return The welcome information
     */
    Update getWelcomeInfo(S state);

    /**
     * Processes welcome information generated by {@link SignatureProtocol#getWelcomeInfo}. If the welcome
     * comes from initial group creation, then {@code welcomeInfo.getBytes()} should be null.
     * Otherwise (i.e., we were added to the group after its creation), this is called after calling {@link
     * SignatureProtocol#verify} on the Welcome Message's signature, but before calling any other methods.
     *
     * @param state       The state to reference (immutably).
     * @param welcomeInfo The welcome information output by {@code sender}'s {@link SignatureProtocol#getWelcomeInfo}
     *                    method, or an {@link Update} wrapping null if the welcome message comes from initial group creation.
     * @return The updated state.
     */
    S processWelcomeInfo(S state, Update welcomeInfo, IdentityKey sender);

    /**
     * Signs the given Welcome Message.  Typically, Welcome Messages will be signed differently from non-welcome
     * messages, since new group members must verify the Welcome Message's signature before calling {@link
     * SignatureProtocol#processWelcomeInfo} on the welcome info it contains, hence they will only know our public
     * {@link IdentityKey} instead of our current post-compromise secure signing key.
     *
     * @param state   The state to reference (immutably).
     * @param message The message to be signed.
     * @return The signature for the message (excluding the message itself).
     */
    Signature getWelcomeSignature(S state, byte[] message);

    class Signature extends ByteHolder {
        public Signature(byte[] bytes) {
            super(bytes);
        }

        public static Signature of(byte[] bytes) {
            return new Signature(bytes);
        }
    }

    class Update extends ByteHolder {
        public Update(byte[] bytes) {
            super(bytes);
        }

        public static Update of(byte[] bytes) {
            return new Update(bytes);
        }
    }

    interface State {
    }
}
